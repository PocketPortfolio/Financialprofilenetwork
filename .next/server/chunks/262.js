"use strict";exports.id=262,exports.ids=[262],exports.modules={90262:(e,t,a)=>{a.d(t,{K:()=>n});var r=a(17577),s=a(27153),d=a(76),o=a(75114);class i{static async addTrade(e,t){try{let a={...t,uid:e,createdAt:d.EK.now(),updatedAt:d.EK.now()};return(await (0,d.ET)((0,d.hJ)(o.db,"trades"),a)).id}catch(e){throw e}}static async getTrades(e){try{let t=(0,d.IO)((0,d.hJ)(o.db,"trades"),(0,d.ar)("uid","==",e));return(await (0,d.PL)(t)).docs.map(e=>({id:e.id,...e.data()})).sort((e,t)=>{let a=e.createdAt?.toDate?e.createdAt.toDate().getTime():0;return(t.createdAt?.toDate?t.createdAt.toDate().getTime():0)-a})}catch(e){throw e}}static async deleteTrade(e,t){try{if(!o.db)throw Error("Firebase database not initialized");let a=(0,d.JU)(o.db,"trades",t),r=await (0,d.QT)(a);if(!r.exists())throw Error("Trade not found");if(r.data().uid!==e)throw Error("Insufficient permissions to delete this trade");await (0,d.oe)(a)}catch(e){if("permission-denied"===e.code)throw Error("Permission denied. Please ensure you are signed in and own this trade.");if("not-found"===e.code)throw Error("Trade not found. It may have already been deleted.");if(e.message)throw Error(e.message);throw Error("Failed to delete trade. Please try again.")}}static async cleanupOrphanedTrades(e){try{let t=(0,d.IO)((0,d.hJ)(o.db,"trades")),a=await (0,d.PL)(t),r=0;for(let t of a.docs){let a=t.data();(!a.uid||a.uid!==e)&&(await (0,d.oe)(t.ref),r++)}return r}catch(e){throw e}}static async updateTrade(e,t,a){try{await (0,d.r7)((0,d.JU)(o.db,"trades",t),{...a,updatedAt:d.EK.now()})}catch(e){throw e}}static async importTrades(e,t){try{let a=[],r=d.EK.now();for(let s of t)a.push({...s,uid:e,createdAt:r,updatedAt:r});return(await Promise.all(a.map(e=>(0,d.ET)((0,d.hJ)(o.db,"trades"),e)))).map(e=>e.id)}catch(e){throw e}}static async migrateTrades(e,t){try{if(!t||0===t.length)return;let a=(0,d.qs)(o.db),r=d.EK.now(),s=0;for(let i of t)try{let t=(0,d.JU)(o.db,"trades",i),n=await (0,d.QT)(t);if(n.exists()){let d=n.data();(!d.uid||d.uid!==e)&&(a.update(t,{uid:e,updatedAt:r}),s++)}}catch(e){}s>0&&await a.commit()}catch(e){throw e}}static async deleteAllTrades(e){try{let t=(0,d.hJ)(o.db,"trades"),a=(0,d.IO)(t,(0,d.ar)("uid","==",e)),r=await (0,d.PL)(a);if(r.empty)return 0;let s=(0,d.qs)(o.db);return r.docs.forEach(e=>{s.delete(e.ref)}),await s.commit(),r.size}catch(e){throw e}}}function n(){let{user:e,isAuthenticated:t}=(0,s.a)(),[a,d]=(0,r.useState)([]),[o,n]=(0,r.useState)(!1),[c,l]=(0,r.useState)(null),u=(0,r.useCallback)(async()=>{n(!0),l(null);try{if(t&&e){let t=await i.getTrades(e.uid);d(t)}else{let e=localStorage.getItem("pocket-portfolio-local-trades");if(e){let t=JSON.parse(e);d(t)}else d([])}}catch(e){l(e instanceof Error?e.message:"Failed to load trades")}finally{n(!1)}},[e,t]),h=(0,r.useCallback)(async a=>{try{if(t&&e){let t=await i.addTrade(e.uid,a),r={...a,id:t,uid:e.uid,createdAt:{seconds:Date.now()/1e3,nanoseconds:0},updatedAt:{seconds:Date.now()/1e3,nanoseconds:0}};return d(e=>[r,...e]),t}{let e={...a,id:`local-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,uid:"local",createdAt:{seconds:Date.now()/1e3,nanoseconds:0},updatedAt:{seconds:Date.now()/1e3,nanoseconds:0}};return d(t=>{let a=[e,...t];return localStorage.setItem("pocket-portfolio-local-trades",JSON.stringify(a)),a}),e.id}}catch(e){throw l(e instanceof Error?e.message:"Failed to add trade"),e}},[e,t]),w=(0,r.useCallback)(async a=>{let r=a.startsWith("local-");try{r?d(e=>{let t=e.filter(e=>e.id!==a);return localStorage.setItem("pocket-portfolio-local-trades",JSON.stringify(t)),t}):t&&e?(await i.deleteTrade(e.uid,a),d(e=>e.filter(e=>e.id!==a))):d(e=>{let t=e.filter(e=>e.id!==a);return localStorage.setItem("pocket-portfolio-local-trades",JSON.stringify(t)),t})}catch(e){throw l(e instanceof Error?e.message:"Failed to delete trade"),e}},[e,t,a]),f=(0,r.useCallback)(async(t,a)=>{if(!e)throw Error("User not authenticated");try{await i.updateTrade(e.uid,t,a),d(e=>e.map(e=>e.id===t?{...e,...a,updatedAt:{seconds:Date.now()/1e3,nanoseconds:0}}:e))}catch(e){throw l(e instanceof Error?e.message:"Failed to update trade"),e}},[e]),p=(0,r.useCallback)(async a=>{try{if(t&&e){let t=await i.importTrades(e.uid,a),r=a.map((a,r)=>({...a,id:t[r],uid:e.uid,createdAt:{seconds:Date.now()/1e3,nanoseconds:0},updatedAt:{seconds:Date.now()/1e3,nanoseconds:0}}));return d(e=>[...r,...e]),t}{let e=a.map((e,t)=>({...e,id:`local-${Date.now()}-${t}-${Math.random().toString(36).substr(2,9)}`,uid:"local",createdAt:{seconds:Date.now()/1e3,nanoseconds:0},updatedAt:{seconds:Date.now()/1e3,nanoseconds:0}}));return d(t=>{let a=[...e,...t];return localStorage.setItem("pocket-portfolio-local-trades",JSON.stringify(a)),a}),e.map(e=>e.id)}}catch(e){throw l(e instanceof Error?e.message:"Failed to import trades"),e}},[e,t]),y=(0,r.useCallback)(async t=>{if(!e)throw Error("User not authenticated");try{await i.migrateTrades(e.uid,t),await u()}catch(e){throw l(e instanceof Error?e.message:"Failed to migrate trades"),e}},[e,u]),{realTrades:m,mockTrades:g,validTrades:T,userTickers:E,positions:b,totalInvested:A,totalTrades:k,totalPositions:D}=(0,r.useMemo)(()=>{let e=a.filter(e=>!e.mock),t=a.filter(e=>e.mock),r=e.filter(e=>!(!/^[A-Z0-9.-]{1,10}$/.test(e.ticker)||isNaN(e.qty)||isNaN(e.price)||e.qty<=0||e.price<=0)),s=Array.from(new Set(r.map(e=>e.ticker))),d=e.reduce((e,t)=>{let{ticker:a,qty:r,price:s,type:d,date:o}=t;if(e[a]||(e[a]={ticker:a,shares:0,avgCost:0,currency:t.currency||"USD",totalTrades:0,lastTradeDate:o,isMock:!1}),"BUY"===d){let t=e[a].shares*e[a].avgCost+r*s;e[a].shares+=r,e[a].avgCost=t/e[a].shares}else e[a].shares-=r;return e[a].totalTrades+=1,e[a].lastTradeDate=o,e},{}),o=Object.values(d).reduce((e,t)=>e+t.avgCost*t.shares,0),i=e.length,n=Object.keys(d).length;return{realTrades:e,mockTrades:t,validTrades:r,userTickers:s,positions:d,totalInvested:o,totalTrades:i,totalPositions:n}},[a]);return{trades:a,loading:o,error:c,userTickers:E,totalInvested:A,totalTrades:k,totalPositions:D,addTrade:h,deleteTrade:w,updateTrade:f,importTrades:p,migrateTrades:y,deleteAllTrades:(0,r.useCallback)(async()=>{if(!e)throw Error("User not authenticated");try{let t=await i.deleteAllTrades(e.uid);return d([]),t}catch(e){throw l(e instanceof Error?e.message:"Failed to delete all trades"),e}},[e]),cleanupOrphanedTrades:(0,r.useCallback)(async()=>{if(!e)throw Error("User not authenticated");try{let t=await i.cleanupOrphanedTrades(e.uid);return await u(),t}catch(e){throw l(e instanceof Error?e.message:"Failed to cleanup orphaned trades"),e}},[e,u]),refreshTrades:u}}}};