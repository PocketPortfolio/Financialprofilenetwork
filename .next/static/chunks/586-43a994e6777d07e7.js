"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[586],{1586:function(e,t,a){a.d(t,{K:function(){return n}});var r=a(2265),d=a(4330),s=a(5978),o=a(7835);class i{static async addTrade(e,t){try{let a={...t,uid:e,createdAt:s.EK.now(),updatedAt:s.EK.now()};return(await (0,s.ET)((0,s.hJ)(o.db,"trades"),a)).id}catch(e){throw e}}static async getTrades(e){try{let t=(0,s.IO)((0,s.hJ)(o.db,"trades"),(0,s.ar)("uid","==",e));return(await (0,s.PL)(t)).docs.map(e=>({id:e.id,...e.data()})).sort((e,t)=>{var a,r;let d=(null===(a=e.createdAt)||void 0===a?void 0:a.toDate)?e.createdAt.toDate().getTime():0;return((null===(r=t.createdAt)||void 0===r?void 0:r.toDate)?t.createdAt.toDate().getTime():0)-d})}catch(e){throw e}}static async deleteTrade(e,t){try{if(!o.db)throw Error("Firebase database not initialized");let a=(0,s.JU)(o.db,"trades",t),r=await (0,s.QT)(a);if(!r.exists())throw Error("Trade not found");if(r.data().uid!==e)throw Error("Insufficient permissions to delete this trade");await (0,s.oe)(a)}catch(e){if("permission-denied"===e.code)throw Error("Permission denied. Please ensure you are signed in and own this trade.");if("not-found"===e.code)throw Error("Trade not found. It may have already been deleted.");if(e.message)throw Error(e.message);throw Error("Failed to delete trade. Please try again.")}}static async cleanupOrphanedTrades(e){try{let t=(0,s.IO)((0,s.hJ)(o.db,"trades")),a=await (0,s.PL)(t),r=0;for(let t of a.docs){let a=t.data();(!a.uid||a.uid!==e)&&(await (0,s.oe)(t.ref),r++)}return r}catch(e){throw e}}static async updateTrade(e,t,a){try{await (0,s.r7)((0,s.JU)(o.db,"trades",t),{...a,updatedAt:s.EK.now()})}catch(e){throw e}}static async importTrades(e,t){try{let a=[],r=s.EK.now();for(let d of t)a.push({...d,uid:e,createdAt:r,updatedAt:r});return(await Promise.all(a.map(e=>(0,s.ET)((0,s.hJ)(o.db,"trades"),e)))).map(e=>e.id)}catch(e){throw e}}static async migrateTrades(e,t){try{if(!t||0===t.length)return;let a=(0,s.qs)(o.db),r=s.EK.now(),d=0;for(let i of t)try{let t=(0,s.JU)(o.db,"trades",i),n=await (0,s.QT)(t);if(n.exists()){let s=n.data();(!s.uid||s.uid!==e)&&(a.update(t,{uid:e,updatedAt:r}),d++)}}catch(e){}d>0&&await a.commit()}catch(e){throw e}}static async deleteAllTrades(e){try{let t=(0,s.hJ)(o.db,"trades"),a=(0,s.IO)(t,(0,s.ar)("uid","==",e)),r=await (0,s.PL)(a);if(r.empty)return 0;let d=(0,s.qs)(o.db);return r.docs.forEach(e=>{d.delete(e.ref)}),await d.commit(),r.size}catch(e){throw e}}}function n(){let{user:e,isAuthenticated:t}=(0,d.a)(),[a,s]=(0,r.useState)([]),[o,n]=(0,r.useState)(!1),[c,l]=(0,r.useState)(null),u=(0,r.useCallback)(async()=>{n(!0),l(null);try{if(t&&e){let t=await i.getTrades(e.uid);s(t)}else{let e=localStorage.getItem("pocket-portfolio-local-trades");if(e){let t=JSON.parse(e);s(t)}else s([])}}catch(e){l(e instanceof Error?e.message:"Failed to load trades")}finally{n(!1)}},[e,t]);(0,r.useEffect)(()=>{u()},[null==e?void 0:e.uid,t]);let h=(0,r.useCallback)(async a=>{try{if(t&&e){let t=await i.addTrade(e.uid,a),r={...a,id:t,uid:e.uid,createdAt:{seconds:Date.now()/1e3,nanoseconds:0},updatedAt:{seconds:Date.now()/1e3,nanoseconds:0}};return s(e=>[r,...e]),t}{let e={...a,id:"local-".concat(Date.now(),"-").concat(Math.random().toString(36).substr(2,9)),uid:"local",createdAt:{seconds:Date.now()/1e3,nanoseconds:0},updatedAt:{seconds:Date.now()/1e3,nanoseconds:0}};return s(t=>{let a=[e,...t];return localStorage.setItem("pocket-portfolio-local-trades",JSON.stringify(a)),a}),e.id}}catch(e){throw l(e instanceof Error?e.message:"Failed to add trade"),e}},[e,t]),f=(0,r.useCallback)(async a=>{let r=a.startsWith("local-");try{r?s(e=>{let t=e.filter(e=>e.id!==a);return localStorage.setItem("pocket-portfolio-local-trades",JSON.stringify(t)),t}):t&&e?(await i.deleteTrade(e.uid,a),s(e=>e.filter(e=>e.id!==a))):s(e=>{let t=e.filter(e=>e.id!==a);return localStorage.setItem("pocket-portfolio-local-trades",JSON.stringify(t)),t})}catch(e){throw l(e instanceof Error?e.message:"Failed to delete trade"),e}},[e,t,a]),w=(0,r.useCallback)(async(t,a)=>{if(!e)throw Error("User not authenticated");try{await i.updateTrade(e.uid,t,a),s(e=>e.map(e=>e.id===t?{...e,...a,updatedAt:{seconds:Date.now()/1e3,nanoseconds:0}}:e))}catch(e){throw l(e instanceof Error?e.message:"Failed to update trade"),e}},[e]),p=(0,r.useCallback)(async a=>{try{if(t&&e){let t=await i.importTrades(e.uid,a),r=a.map((a,r)=>({...a,id:t[r],uid:e.uid,createdAt:{seconds:Date.now()/1e3,nanoseconds:0},updatedAt:{seconds:Date.now()/1e3,nanoseconds:0}}));return s(e=>[...r,...e]),t}{let e=a.map((e,t)=>({...e,id:"local-".concat(Date.now(),"-").concat(t,"-").concat(Math.random().toString(36).substr(2,9)),uid:"local",createdAt:{seconds:Date.now()/1e3,nanoseconds:0},updatedAt:{seconds:Date.now()/1e3,nanoseconds:0}}));return s(t=>{let a=[...e,...t];return localStorage.setItem("pocket-portfolio-local-trades",JSON.stringify(a)),a}),e.map(e=>e.id)}}catch(e){throw l(e instanceof Error?e.message:"Failed to import trades"),e}},[e,t]),y=(0,r.useCallback)(async t=>{if(!e)throw Error("User not authenticated");try{await i.migrateTrades(e.uid,t),await u()}catch(e){throw l(e instanceof Error?e.message:"Failed to migrate trades"),e}},[e,u]),{realTrades:m,mockTrades:g,validTrades:E,userTickers:T,positions:b,totalInvested:A,totalTrades:k,totalPositions:D}=(0,r.useMemo)(()=>{let e=a.filter(e=>!e.mock),t=a.filter(e=>e.mock),r=e.filter(e=>!(!/^[A-Z0-9.-]{1,10}$/.test(e.ticker)||isNaN(e.qty)||isNaN(e.price)||e.qty<=0||e.price<=0)),d=Array.from(new Set(r.map(e=>e.ticker))),s=e.reduce((e,t)=>{let{ticker:a,qty:r,price:d,type:s,date:o}=t;if(e[a]||(e[a]={ticker:a,shares:0,avgCost:0,currency:t.currency||"USD",totalTrades:0,lastTradeDate:o,isMock:!1}),"BUY"===s){let t=e[a].shares*e[a].avgCost+r*d;e[a].shares+=r,e[a].avgCost=t/e[a].shares}else e[a].shares-=r;return e[a].totalTrades+=1,e[a].lastTradeDate=o,e},{}),o=Object.values(s).reduce((e,t)=>e+t.avgCost*t.shares,0),i=e.length,n=Object.keys(s).length;return{realTrades:e,mockTrades:t,validTrades:r,userTickers:d,positions:s,totalInvested:o,totalTrades:i,totalPositions:n}},[a]);return(0,r.useEffect)(()=>{a.length},[a.length,A,m.length,g.length,b,t,null==e?void 0:e.uid]),{trades:a,loading:o,error:c,userTickers:T,totalInvested:A,totalTrades:k,totalPositions:D,addTrade:h,deleteTrade:f,updateTrade:w,importTrades:p,migrateTrades:y,deleteAllTrades:(0,r.useCallback)(async()=>{if(!e)throw Error("User not authenticated");try{let t=await i.deleteAllTrades(e.uid);return s([]),t}catch(e){throw l(e instanceof Error?e.message:"Failed to delete all trades"),e}},[e]),cleanupOrphanedTrades:(0,r.useCallback)(async()=>{if(!e)throw Error("User not authenticated");try{let t=await i.cleanupOrphanedTrades(e.uid);return await u(),t}catch(e){throw l(e instanceof Error?e.message:"Failed to cleanup orphaned trades"),e}},[e,u]),refreshTrades:u}}}}]);