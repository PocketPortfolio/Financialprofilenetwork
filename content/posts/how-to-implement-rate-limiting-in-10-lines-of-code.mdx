---
title: "How to Implement Rate Limiting in 10 Lines of Code"
date: "2026-01-22"
description: "Learn to implement rate limiting in your application with a concise, effective 10-line code snippet."
tags: ["implement", "rate", "limiting"]
author: "Pocket Portfolio Team"
image: "/images/blog/how-to-implement-rate-limiting-in-10-lines-of-code.png"
pillar: "technical"
category: "how-to-in-tech"
---

Implementing rate limiting is crucial for protecting your APIs and services from abuse and overuse. This concise guide will show you how to achieve this in just 10 lines of code.

```pytho
n
from flask import Flask, request, jsonify
from functools import wraps
import time

app = Flask(__name__)
clients = {}

def rate_limiter(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        client = request.remote_addr
        if client not in clients or time.time() - clients[client] > 60:
            clients[client] = time.time()
            return f(*args, **kwargs)
        else:
            return jsonify({"error": "rate limit exceeded"}), 429
    return decorated_function

@app.route("/data")
@rate_limiter
def data():
    return "Protected Data"
```

### Key Concepts

- **Decorator Pattern**: We use a decorator (`@rate_limiter`) to wrap any function that we want to protect with rate limiting. This pattern allows for clean and reusable code.
- **Client Tracking**: The `clients` dictionary keeps track of each client's last request time. The key is the client's IP address, obtained via `request.remote_addr`.
- **Rate Limiting Logic**: Before executing the protected function, we check if the client's last request was made within the past 60 seconds. If so, we return a 429 error; otherwise, we update the client's last request time and proceed.

### Quick Tip

When implementing rate limiting, consider using more sophisticated methods for identifying clients than just IP addresses, as users behind NAT or proxy services might share the same IP address. Additionally, for production environments, consider storing the `clients` data in a more persistent storage solution like Redis to handle multiple server instances and ensure scalability.

Implementing rate limiting efficiently can significantly improve your application's reliability and user experience by preventing service abuse and ensuring fair resource distribution among users.