---
title: "How to Implement Rate Limiting in 10 Lines of Code"
date: "2026-01-22"
description: "Learn how to efficiently implement rate limiting in your application with just 10 lines of code to manage traffic flow."
tags: ["implement", "rate", "limiting"]
author: "Pocket Portfolio Team"
image: "/images/blog/how-to-implement-rate-limiting-in-10-lines-of-code.png"
pillar: "technical"
category: "how-to-in-tech"
---

Rate limiting is essential for controlling the flow of requests to your application, preventing overuse of resources and ensuring fair usage among users. Here's how you can implement it succinctly.

```pytho
n
from flask import Flask, request, make_response
from functools import wraps
import time

app = Flask(__name__)
clients = {}

def rate_limiter(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        client_ip = request.remote_addr
        if client_ip not in clients:
            clients[client_ip] = time.time()
        elif time.time() - clients[client_ip] < 60:
            return make_response("Rate limit exceeded. Try again later.", 429)
        clients[client_ip] = time.time()
        return f(*args, **kwargs)
    return decorated_function

@app.route("/")
@rate_limiter
def home():
    return "Welcome, you are not rate-limited!"

if __name__ == "__main__":
    app.run(debug=True)
```

### Explanation

- **Flask Framework**: This example uses Flask, a lightweight WSGI web application framework in Python, to quickly set up an endpoint.
- **Decorator Pattern**: The `rate_limiter` function is a decorator that wraps around any Flask route you wish to protect with rate limiting.
- **Client Tracking**: It uses the client's IP address to track the requests. Each client is allowed one request per minute (modifiable as needed).
- **Time Checks**: The core mechanism checks the time elapsed since the last recorded request from a specific IP. If it's less than a set threshold (60 seconds here), it returns a 429 error, indicating too many requests.

### Quick Tip

While this implementation is straightforward and works well for small-scale applications, consider using more sophisticated tools like Redis for distributed rate limiting in production environments to handle higher traffic efficiently and ensure scalability.

This approach provides a basic yet effective way to implement rate limiting, protecting your application from potential abuse and ensuring a smoother user experience across the board.