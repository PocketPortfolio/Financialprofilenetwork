---
title: "How to Implement Rate Limiting in 10 Lines of Code"
date: "2026-01-22"
description: "Quick guide on how to implement rate limiting in your app using just 10 lines of code to manage API request traffic efficiently."
tags: ["implement", "rate", "limiting"]
author: "Pocket Portfolio Team"
image: "/images/blog/how-to-implement-rate-limiting-in-10-lines-of-code.png"
pillar: "technical"
category: "how-to-in-tech"
---

In the realm of web development, ensuring your application can handle a surge of requests without crashing is essential. One effective strategy to manage this is through rate limiting, which controls how often a user can execute a particular action within a set timeframe. Here's a straightforward way to implement rate limiting in just 10 lines of code.

### Direct Solution with Code

Let's use a simple Express.js server as our example. We will implement rate limiting using a middleware function.

```javascrip
t
const express = require('express');
const app = express();
const PORT = 3000;

const rateLimit = (req, res, next) => {
  const limit = 100; // Max requests
  const timeFrame = 3600000; // Time frame in milliseconds (1 hour)
  const user = req.ip; // Key to track (e.g., IP address)
  global.users = global.users || {};
  global.users[user] = global.users[user] || { count: 0, startTime: new Date().getTime() };

  if (new Date().getTime() - global.users[user].startTime < timeFrame) {
    if (global.users[user].count < limit) {
      global.users[user].count++;
      next();
    } else {
      res.status(429).send('Rate limit exceeded. Try again later.');
    }
  } else {
    global.users[user] = { count: 1, startTime: new Date().getTime() };
    next();
  }
};

app.use(rateLimit);

app.get('/', (req, res) => {
  res.send('Hello World!');
});

app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
```

### Explanation of Key Concepts

This code defines a middleware function `rateLimit` that tracks requests from a unique user (in this case, using their IP address as the identifier) and limits the number of requests they can make to 100 per hour. If a user exceeds this limit, they receive a `429` status code indicating too many requests. The tracking of request counts and timestamps is stored in a global object `users`.

### Quick Tip

Remember, using a global object for tracking is only viable for demonstration or very small applications. In production, consider using a more robust solution like Redis to handle rate limiting across multiple server instances efficiently and to prevent memory leaks or inconsistencies.

Implementing rate limiting is crucial for protecting your APIs and ensuring fair usage among consumers. This simple yet effective approach can be the first line of defense against abuse or accidental overuse.