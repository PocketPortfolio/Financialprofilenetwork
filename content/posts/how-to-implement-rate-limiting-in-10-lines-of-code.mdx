---
title: "How to Implement Rate Limiting in 10 Lines of Code"
date: "2026-01-22"
description: "Learn to implement rate limiting efficiently with our quick guide, featuring an easy-to-follow code example."
tags: ["implement", "rate", "limiting"]
author: "Pocket Portfolio Team"
image: "/images/blog/how-to-implement-rate-limiting-in-10-lines-of-code.png"
pillar: "technical"
category: "how-to-in-tech"
---

Managing server resources and ensuring fair usage requires an effective strategy. Rate limiting is pivotal in preventing single users from monopolizing resources, ensuring equitable access for all. Here's a succinct way to implement rate limiting in just 10 lines of code, using Python and the Flask web framework.

```pytho
n
from flask import Flask, request, jsonify
from functools import wraps
import time

app = Flask(__name__)
CLIENTS = {}

def rate_limiter(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        client_id = request.remote_addr
        if client_id not in CLIENTS or time.time() - CLIENTS[client_id] > 60:
            CLIENTS[client_id] = time.time()
            return f(*args, **kwargs)
        else:
            return jsonify({"error": "Too many requests"}), 429
    return decorated_function

@app.route('/')
@rate_limiter
def home():
    return "Welcome to the rate-limited resource!"

if __name__ == "__main__":
    app.run(debug=True)
```

**Key Concepts:**

- **Decorator Pattern:** The `@rate_limiter` function is a decorator, wrapping around any route you wish to protect with rate limiting. This pattern allows for clean, reusable code.
- **Client Tracking:** The `CLIENTS` dictionary tracks request timestamps by client IP (`request.remote_addr`). This simple method is effective for basic rate limiting but consider more sophisticated tracking for production environments.
- **Time-based Validation:** We check the time elapsed since the last request. If it exceeds our limit (60 seconds in this example), we allow the request and update the timestamp. Otherwise, we return a 429 error, indicating too many requests.

**Quick Tip:** This basic implementation uses the client's IP for identification, which might not be ideal in all scenarios, especially in environments where users are behind NAT. Consider using authentication tokens for a more robust approach in such cases.

Implementing rate limiting doesn't have to be complicated. With this straightforward approach, you can protect your resources and ensure a fair user experience on your platform.