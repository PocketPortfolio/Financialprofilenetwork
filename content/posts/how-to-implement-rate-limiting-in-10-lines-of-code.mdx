---
title: "How to Implement Rate Limiting in 10 Lines of Code"
date: "2026-01-22"
description: "Quick guide on how to implement rate limiting efficiently in your applications using minimal code."
tags: ["implement", "rate", "limiting"]
author: "Pocket Portfolio Team"
image: "/images/blog/how-to-implement-rate-limiting-in-10-lines-of-code.png"
pillar: "technical"
category: "how-to-in-tech"
---

In modern web development, effectively managing the flow of requests to your server is crucial to maintain performance and prevent abuse. Rate limiting is a strategy to control the number of requests a user can make to an API within a given timeframe. Let's dive into how to implement this in just 10 lines of code.

```pytho
n
from flask import Flask, request, jsonify
from functools import wraps
import time

app = Flask(__name__)
clients = {}

def rate_limiter(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        client_ip = request.remote_addr
        if client_ip not in clients:
            clients[client_ip] = time.time()
        elif time.time() - clients[client_ip] < 60: # 60 seconds window
            return jsonify({"error": "Rate limit exceeded"}), 429
        clients[client_ip] = time.time()
        return func(*args, **kwargs)
    return wrapper

@app.route('/data', methods=['GET'])
@rate_limiter
def get_data():
    return jsonify({"data": "Here is your data"})
```

This Python snippet utilizes Flask, a popular web framework, to demonstrate a straightforward rate limiting mechanism. The core concepts here are:

- **Decorators**: The `rate_limiter` function is a decorator that wraps any Flask route you want to protect with rate limiting.
- **Client Identification**: It identifies clients based on their IP address, which is accessed via `request.remote_addr`.
- **Time Window**: The code enforces a 60-second time window for request limits, customizable as per requirements.

**Quick Tip**: Ensure your application correctly handles users behind NATs or proxy servers, as they might share the same IP address. In such cases, consider other identifiers like API keys for rate limiting.

Implementing rate limiting is a balance between protecting your resources and providing a smooth user experience. This example provides a starting point, but real-world applications might require more sophisticated strategies, such as dynamic rate limits based on server load or user behavior.

By incorporating simple yet effective rate limiting, you can safeguard your application from potential abuse while ensuring it remains responsive and available to genuine users.