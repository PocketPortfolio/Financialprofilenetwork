---
title: "How to Implement Rate Limiting in 10 Lines of Code"
date: "2026-01-22"
description: "Learn how to implement rate limiting efficiently in your application with this quick, 10-line JavaScript code guide."
tags: ["implement", "rate", "limiting"]
author: "Pocket Portfolio Team"
image: "/images/blog/how-to-implement-rate-limiting-in-10-lines-of-code.png"
pillar: "technical"
category: "how-to-in-tech"
---

Rate limiting is crucial for preventing abuse and ensuring fair resource access in web applications. Here's how you can implement it in 10 lines of code using JavaScript.

```javascrip
t
function rateLimiter(maxRequests, timePeriod, cache) {
  return (req, res, next) => {
    const key = req.ip;
    const now = Date.now();
    if (!cache[key]) {
      cache[key] = { count: 1, startTime: now };
      return next();
    }
    const userData = cache[key];
    if (now - userData.startTime < timePeriod) {
      if (userData.count < maxRequests) {
        userData.count++;
        return next();
      }
      return res.status(429).send('Too many requests, please try again later.');
    }
    userData.count = 1;
    userData.startTime = now;
    return next();
  };
}
```

**Key Concepts:**

- **maxRequests**: The maximum number of requests a user can make within the specified **timePeriod**.
- **timePeriod**: The duration (in milliseconds) in which **maxRequests** applies.
- **cache**: A simple object to track request counts and timestamps per IP address.

This function creates a middleware that tracks the number of requests from each IP address, using a simple **cache** object for storage. If the number of requests exceeds **maxRequests** within **timePeriod**, it returns a 429 status code, indicating too many requests.

**Quick Tip:** Ensure your cache strategy is scalable. In memory storage, as shown, works for prototypes or low-traffic scenarios. For production environments, consider using a more robust solution like Redis to handle rate limiting across multiple instances or servers.

**Gotcha:** Be mindful of users behind NATs or proxies, as they might share an IP address. Implementing account-based or token-based rate limiting in addition to IP-based limiting can help mitigate this issue.