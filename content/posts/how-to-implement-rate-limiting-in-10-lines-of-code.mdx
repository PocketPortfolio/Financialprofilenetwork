---
title: "How to Implement Rate Limiting in 10 Lines of Code"
date: "2026-01-22"
description: "Learn to implement efficient rate limiting in your apps with this concise, practical guide. Quick setup, immediate results."
tags: ["implement", "rate", "limiting"]
author: "Pocket Portfolio Team"
image: "/images/blog/how-to-implement-rate-limiting-in-10-lines-of-code.png"
pillar: "technical"
category: "how-to-in-tech"
---

Implementing rate limiting is essential to protect your APIs from abuse and to ensure fair usage among users. This brief guide demonstrates how to set up a basic rate limiter in just 10 lines of code using Node.js and Redis.

### Solution

```javascrip
t
const redis = require('redis');
const client = redis.createClient();
const { promisify } = require('util');
const getAsync = promisify(client.get).bind(client);

const rateLimit = async (userId) => {
  let requests = await getAsync(userId);
  if (requests && requests >= 5) return false;
  client.multi().incr(userId).expire(userId, 60).exec();
  return true;
};
```

### Explanation

1. **Redis Setup**: We use Redis, a fast, in-memory key-value store, to track the number of requests a user has made. Redis is ideal for this due to its speed and simplicity in handling expiry of keys.
   
2. **Promisifying Redis Calls**: Node.js Redis library uses callbacks by default. We use `promisify` to work with async/await for better readability and flow control.

3. **The `rateLimit` Function**: This function accepts a `userId` and checks the number of requests already made.
   - If a user has made 5 or more requests within a minute (`if (requests && requests >= 5)`), it returns `false`, indicating the user has been rate limited.
   - Otherwise, it increments the request count and sets an expiry of 60 seconds on the record. It then returns `true`, allowing the request.

### Quick Tip

In a production environment, consider enhancing this basic rate limiter with more sophisticated rules. For example, differentiating between read and write operations or applying different limits based on the user's subscription level.

### Gotcha

Remember to handle Redis connection errors and downtimes gracefully in your application to avoid denial of service to your users when Redis is unavailable.

Implementing rate limiting is a critical step in creating robust, scalable web applications. This simple approach offers a lightweight, effective solution, but always consider your specific application needs and traffic patterns when designing rate limiting strategies.