---
title: "How to Implement Rate Limiting in 10 Lines of Code"
date: "2026-01-22"
description: "Learn to implement rate limiting efficiently with a concise, 10-line Python code snippet, perfect for managing resource access."
tags: ["implement", "rate", "limiting"]
author: "Pocket Portfolio Team"
image: "/images/blog/how-to-implement-rate-limiting-in-10-lines-of-code.png"
pillar: "technical"
category: "how-to-in-tech"
---

Rate limiting is crucial for preventing abuse and ensuring equitable resource access in web applications. Here's how you can implement it in just 10 lines of code using Python.

```pytho
n
import time

class RateLimiter:
    def __init__(self, max_requests, time_window):
        self.requests = {}
        self.max_requests = max_requests
        self.time_window = time_window

    def is_allowed(self, user_id):
        current_time = time.time()
        if user_id not in self.requests:
            self.requests[user_id] = [current_time]
            return True
        self.requests[user_id] = [timestamp for timestamp in self.requests[user_id] if current_time - timestamp < self.time_window]
        if len(self.requests[user_id]) < self.max_requests:
            self.requests[user_id].append(current_time)
            return True
        return False
```

**Key Concepts:**

- **Rate Limiting:** A technique used to control the number of requests a user can make to a resource within a given timeframe.
- **`max_requests`:** The maximum number of requests allowed.
- **`time_window`:** The timeframe (in seconds) for which the `max_requests` count applies.
- **`user_id`:** A unique identifier for each user, which could be an IP address, user account id, or any identifier that distinguishes one user from another.
- **`is_allowed`:** A method that checks if a user's request is within the rate limits. If true, the request is permitted; otherwise, it's denied.

**Quick Tip:**

This code snippet uses a sliding window algorithm, which ensures fairness and flexibility in rate limiting. It's memory-efficient because it only keeps timestamps of requests within the specified `time_window`, discarding older entries.

**Gotcha:**

Be mindful of the `time_window` and `max_requests` values. Setting these too low might overly restrict access, while too high values may not effectively prevent abuse. Adjust these parameters based on the specific usage patterns and requirements of your application.

Implementing an efficient rate limiting mechanism doesn't have to be complex or verbose. This concise approach provides a robust starting point for managing access to resources in your applications.